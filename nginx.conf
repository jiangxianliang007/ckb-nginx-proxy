worker_processes 4;

error_log /var/log/nginx/error.log info;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
}

http {
    resolver 8.8.8.8 8.8.4.4 valid=30s;
    lua_shared_dict my_cache 30m;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    log_format json_log escape=json '{"realip":"$http_x_forwarded_for","@timestamp":"$time_iso8601","host":"$http_host","request":"$request","req_body":"$request_body","status":"$status","size":$body_bytes_sent,"ua":"$http_user_agent","req_time":"$request_time","uri":"$uri","referer":"$http_referer","xff":"$remote_addr","ups_status":"$upstream_status","ups_addr":"$upstream_addr","ups_time":"$upstream_response_time"}';
    access_log /var/log/nginx/access.log json_log buffer=32k;

    sendfile on;
    keepalive_timeout 65;
    client_max_body_size 10m;
    client_body_buffer_size 10m;
    proxy_buffer_size 128k;
    proxy_buffers 4 256k;
    lua_socket_buffer_size 128k;

    lua_need_request_body on;

    upstream ckb_rpc {
        server DEFAULT_CKR_RPC_IP:8114;  
    }

    server {
        listen 80;
        server_name localhost;

        location / {
            proxy_pass http://ckb_rpc;
	          proxy_request_buffering off;
            more_set_headers "Access-Control-Allow-Credentials: true";
            more_set_headers "Access-Control-Allow-Origin: *";
            more_set_headers "Access-Control-Allow-Headers: Accept,Authorization,authorization,Cache-Control,Content-Type,appkey";
      
            access_by_lua_block {
	              local rich_indexer = "http://rich_indexer_rpc"
                local http = require "resty.http"
                local cjson = require "cjson"

                ngx.req.read_body()
                local body_data = ngx.req.get_body_data()
		            ngx.log(ngx.INFO, "Request body data: ", body_data)

                if not body_data then
                    return ngx.exit(200)
                end

                local json_data = cjson.decode(body_data)
                local method = json_data["method"]
                local disable_methods = {"clear_banned_addresses", "set_ban", "set_network_active", "add_node", "remove_node", "remove_transaction", "clear_tx_pool"}
		
                if method == nil then
                    for i,v in ipairs(json_data) do
                        method = v["method"]
                        for k,v in ipairs(disable_methods) do  
                            if v == method then 
                                ngx.log(ngx.ERR, "Access forbidden for method: ", v)
                                ngx.status = ngx.HTTP_FORBIDDEN
                                ngx.say("This method Access forbidden: ", v)
                                return ngx.exit(ngx.HTTP_FORBIDDEN)
                            end
                        end
                    end
                else
                    for k,v in ipairs(disable_methods) do
                        if v == method then
                            ngx.log(ngx.ERR, "Access forbidden for method: ", v)
                            ngx.status = ngx.HTTP_FORBIDDEN
                            ngx.say("This method Access forbidden: ", v)
                            return ngx.exit(ngx.HTTP_FORBIDDEN)
                        end
                    end
                end

                local forward_methods = { "get_transactions", "get_cells_capacity", "get_cells" }
                local httpc = http.new()
                for _, forward_method in ipairs(forward_methods) do
                    if method == forward_method then
                        local res_b, err = httpc:request_uri(rich_indexer, {
                            method = "POST",
                            body = body_data,
                            headers = {
                                ["Content-Type"] = "application/json",
                            },
                        })

                        if not res_b then
                            ngx.log(ngx.ERR, "Failed to request B server: ", err)
                            return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                        end
                        local response_data_rich_indexer = cjson.decode(res_b.body)

			                  if response_data_rich_indexer.result and response_data_rich_indexer.result.last_cursor then
                            response_data_rich_indexer.result.last_cursor = nil
                        end
			                  ngx.ctx.response_data_rich_indexer = response_data_rich_indexer
                    end
                end
            }

            body_filter_by_lua_block {
                if ngx.status == ngx.HTTP_FORBIDDEN then
                    return
                end

                local cjson = require "cjson"
                local response_data_rpc = ngx.arg[1]

                if response_data_rpc and response_data_rpc ~= "" then
                    local response_data_indexer, err = cjson.decode(response_data_rpc)
                    if not response_data_indexer then
                        ngx.log(ngx.ERR, "Failed to decode JSON from Indexer: ", err)
                        return
                    end

                    if response_data_indexer.result and response_data_indexer.result.last_cursor then
                        response_data_indexer.result.last_cursor = nil
                    end

                    if ngx.ctx.response_data_rich_indexer then
                        local result_indexer = cjson.encode(response_data_indexer.result)
                        local result_rich_indexer = cjson.encode(ngx.ctx.response_data_rich_indexer.result)
                        ngx.log(ngx.ERR, "Result Indexer Length: ", #result_indexer)
                        ngx.log(ngx.ERR, "Result Rich_Indexer Length: ", #result_rich_indexer)

                        -- Function to split long strings into smaller chunks
                        local function log_in_chunks(data, label)
                            local chunk_size = 1024  
                            for i = 1, #data, chunk_size do
                                local chunk = data:sub(i, i + chunk_size - 1)
                                ngx.log(ngx.ERR, label, ": ", chunk)
                            end
                        end

                        log_in_chunks(result_indexer, "Response Data Indexer")
                        log_in_chunks(result_rich_indexer, "Response Data Rich-Indexer")

                        if result_indexer ~= result_rich_indexer then
                            ngx.log(ngx.ERR, "WARNING: Inconsistent results detected!")

                            local discord_webhook_url = "https://discord.com/api/webhooks/xxxxxxxxx"
                            local alert_message = "WARNING: Inconsistent results detected between Server Indexer and Server Rich-Indexer!"
                            local log_time = os.date("%Y/%m/%d %H:%M:%S")
                            
                            local payload = {
                                content = string.format("%s Time: %s", alert_message, log_time),
                            }

                            local dict = ngx.shared.my_cache
                            dict:set("alert_payload", cjson.encode(payload))
                            dict:set("alert_sent", false)

                            ngx.timer.at(0, function()
                                local httpc = require "resty.http".new()
                                local payload = dict:get("alert_payload")
                                local res, err = httpc:request_uri(discord_webhook_url, {
                                    method = "POST",
                                    body = payload,
                                    headers = {
                                        ["Content-Type"] = "application/json",
                                    },
                                    ssl_verify = false,
                                })

                                if not res then
                                    ngx.log(ngx.ERR, "Failed to send alert to Discord: ", err)
                                else
                                    ngx.log(ngx.ERR, "Alert sent to Discord, status: ", res.status)
                                end
                            end)
                        end
                    end
                else
              ngx.log(ngx.INFO, "Normal access log")
                end
            }

        error_page 500 /custom_500_error;
        location = /custom_500_error {
            default_type application/json;
            internal;
            add_header Content-Type application/json;
            return 200 '{"jsonrpc":"2.0","error":{"code":-32700,"message":"Parse error"},"id":null}';
        }
      }
    }
}
